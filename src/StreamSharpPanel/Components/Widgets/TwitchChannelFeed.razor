@implements IDisposable

@inject IJSRuntime Js
@inject ISnackbar Popup
@inject EventSubService Events
@inject ApiCallerService Api


<MudPaper id="@_id" Style="overflow-y:auto;" Height="@Height" Elevation="1">
    @if (_notifs.Count == 0)
    {
        <MudText Align="Align.Center" Class="mt-5 p-3">Here you'll find your channel's recent activity</MudText>
    }
    else
    {
        <MudList T="TwitchNotification" Dense>
            @foreach (var evt in _notifs)
            {
                <MudListItem @key="@evt" Dense="true" Class="mb-1 p-1" Style="cursor:default; user-select:unset" @oncontextmenu="@(x => OpenMenu(x, evt))">
                    @{
                        var (ts, msg) = ParseNotification(evt);

                        <span style="font-weight:bold; cursor:text;">@ts.ToString("HH:mm")</span>
                        <span style="font-style:italic; cursor:text;">@msg</span>
                    }
                </MudListItem>
            }
        </MudList>
    }
</MudPaper>

<MudMenu @ref="@_contextMenu" Open="@_contextMenuOpen" OpenChanged="@(open => _contextMenuOpen = open)" Dense PositionAtCursor>
    @if (_selectedNotif is ChannelBan ban)
    {
        // todo: if possible find a clean way to not show the prompt when the user has already been unbanned, but it's not a big deal
        <MudMenuItem Icon="@Icons.Material.Filled.Gavel" IconColor="Color.Info" AutoClose OnClick="@(() => Unban(ban.UserId))">
            @(ban.IsPermanent ? "Unban" : "End Timeout") @ban.UserName
        </MudMenuItem>
    }

    else if (_selectedNotif is ChannelUnbanRequestCreate { Resolved: false } unban)
    {
        <MudMenuItem Icon="@Icons.Material.Filled.Check" IconColor="Color.Success" AutoClose OnClick="@(() => ResolveUnbanRequest(unban, true))">
            Approve @(unban.UserName)'s unban request
        </MudMenuItem>
        <MudMenuItem Icon="@Icons.Material.Filled.Close" IconColor="Color.Error" AutoClose OnClick="@(() => ResolveUnbanRequest(unban, false))">
            Deny @(unban.UserName)'s unban request
        </MudMenuItem>
    }

    else if (_selectedNotif is AutomodMessageHold { Resolved: false } automodded)
    {
        <MudMenuItem Icon="@Icons.Material.Filled.Check" IconColor="Color.Success" AutoClose OnClick="@(() => ResolveAutomoddedMessage(automodded, true))">
            Allow @(automodded.UserName)'s message
        </MudMenuItem>
        <MudMenuItem Icon="@Icons.Material.Filled.Close" IconColor="Color.Error" AutoClose OnClick="@(() => ResolveAutomoddedMessage(automodded, false))">
            Reject @(automodded.UserName)'s message
        </MudMenuItem>
    }
</MudMenu>


@code {
    [Parameter, EditorRequired] public string BroadcasterId { get; set; } = null!;
    [Parameter, EditorRequired] public string BroadcasterUsername { get; set; } = null!;
    [Parameter] public string Height { get; set; } = "";

    private MudMenu _contextMenu = null!;
    private bool _contextMenuOpen;

    private Guid _id = Guid.NewGuid();

    private CompositeDisposable _eventHandlers = [];
    private List<TwitchNotification> _notifs = [];

    private TwitchNotification? _selectedNotif;


    protected override void OnInitialized()
    {
        _eventHandlers.Add(Events.OnEventReceived<ChannelChatFollow>(AddMessage, x => x.BroadcasterUserId == BroadcasterId));
        _eventHandlers.Add(Events.OnEventReceived<ChannelCheer>(AddMessage, x => x.BroadcasterUserId == BroadcasterId));
        _eventHandlers.Add(Events.OnEventReceived<ChannelRaid>(AddMessage, x => x.ToBroadcasterUserId == BroadcasterId));

        _eventHandlers.Add(Events.OnEventReceived<ChannelBan>(AddMessage, x => x.BroadcasterUserId == BroadcasterId));
        _eventHandlers.Add(Events.OnEventReceived<ChannelUnban>(AddMessage, x => x.BroadcasterUserId == BroadcasterId));
        _eventHandlers.Add(Events.OnEventReceived<ChannelUnbanRequestCreate>(AddMessage, x => x.BroadcasterUserId == BroadcasterId));
        _eventHandlers.Add(Events.OnEventReceived<ChannelUnbanRequestResolve>(AddMessage, x => x.BroadcasterUserId == BroadcasterId));

        _eventHandlers.Add(Events.OnEventReceived<ChannelSubscribe>(AddMessage, x => x.BroadcasterUserId == BroadcasterId));
        _eventHandlers.Add(Events.OnEventReceived<ChannelSubscriptionGift>(AddMessage, x => x.BroadcasterUserId == BroadcasterId));
        _eventHandlers.Add(Events.OnEventReceived<ChannelSubscriptionMessage>(AddMessage, x => x.BroadcasterUserId == BroadcasterId));

        _eventHandlers.Add(Events.OnEventReceived<ChannelPointsCustomRewardAdd>(AddMessage, x => x.BroadcasterUserId == BroadcasterId));

        _eventHandlers.Add(Events.OnEventReceived<AutomodMessageHold>(AddMessage, x => x.BroadcasterUserId == BroadcasterId));
        _eventHandlers.Add(Events.OnEventReceived<AutomodMessageUpdate>(AddMessage, x => x.BroadcasterUserId == BroadcasterId));
    }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender)
        {
            await Js.InvokeVoidAsync("handlerPreventDefault", _id, "contextmenu");
        }
    }

    private async void AddMessage(TwitchNotification message)
    {
        _notifs.Add(message);
        await InvokeAsync(StateHasChanged);
        await Js.InvokeVoidAsyncIgnoreErrors("scrollToBottom", _id);
    }

    private static (DateTime timestamp, string Message) ParseNotification(TwitchNotification notif) => notif switch
    {
        ChannelChatFollow msg => (msg.FollowedAt.LocalDateTime, $"{msg.UserName} followed you!"),
        ChannelCheer msg => (DateTime.Now, $"{(!msg.IsAnonymous ? msg.UserName : "An anonymous user")} cheered {msg.Bits} bits!"),
        ChannelRaid msg => (DateTime.Now, $"{msg.FromBroadcasterUserName} is raiding with {msg.Viewers} viewers!"),

        ChannelBan msg when (msg.IsPermanent) => (msg.BannedAt.LocalDateTime, $"{msg.UserName} was banned by {msg.ModeratorUserName}"),
        ChannelBan msg => (msg.BannedAt.LocalDateTime, $"{msg.UserName} was timed out by {msg.ModeratorUserName} until {msg.EndsAt:yyyy/MM/dd HH:mm}"),
        ChannelUnban msg => (DateTime.Now, $"{msg.UserName} was unbanned by {msg.ModeratorUserName}"),
        ChannelUnbanRequestCreate msg => (msg.CreatedAt.LocalDateTime, $"{msg.UserName} is asking to be unbanned: {msg.Text}"),

        ChannelSubscribe msg => (DateTime.Now, $"{msg.UserName} subscribed with a tier {msg.Tier.TrimEnd('0')}!"),
        ChannelSubscriptionGift msg => (DateTime.Now, msg.Format()),
        ChannelSubscriptionMessage msg => (DateTime.Now, msg.Format()),

        ChannelPointsCustomRewardAdd { Reward: { } rew } msg => (msg.RedeemedAt, $"{msg.UserName} reedemed {rew.Title}"),

        AutomodMessageHold msg => (msg.HeldAt.LocalDateTime, $"{msg.UserName}'s message was held by AutoMod: \"{msg.Message.Text}\""),
        AutomodMessageUpdate { MessageStatus: AutomodMessageStatus.Approved } msg => (DateTime.Now, $"{msg.UserName}'s message held by AutoMod has been approved by {msg.ModeratorUserName}"),
        AutomodMessageUpdate { MessageStatus: AutomodMessageStatus.Denied } msg => (DateTime.Now, $"{msg.UserName}'s message held by AutoMod has been rejected by {msg.ModeratorUserName}"),
        AutomodMessageUpdate { MessageStatus: AutomodMessageStatus.Expired } msg => (DateTime.Now, $"{msg.UserName}'s message held by AutoMod has expired"),

        _ => (default, "")
    };

    private async void OpenMenu(MouseEventArgs e, TwitchNotification notif)
    {
        if (notif is ChannelBan or
            ChannelUnbanRequestCreate { Resolved: false } or
            AutomodMessageHold { Resolved: false })
        {
            _selectedNotif = notif;
            await _contextMenu.OpenMenuAsync(e);
        }
    }

    private async Task Unban(string userId)
    {
        try
        {
            await Api.UnbanUser(BroadcasterId, BroadcasterId, userId);
        }
        catch (Exception ex)
        {
            Popup.Add($"The unbanning failed: {ex.Message}", Severity.Error);
        }
    }

    private async Task ResolveUnbanRequest(ChannelUnbanRequestCreate request, bool approve)
    {
        try
        {
            await Api.ResolveUnbanRequest(BroadcasterId, BroadcasterId, request.Id, approve);
            request.Resolved = true;
        }
        catch (Exception ex)
        {
            Popup.Add($"The unban resolution failed: {ex.Message}", Severity.Error);
        }
    }

    private async Task ResolveAutomoddedMessage(AutomodMessageHold held, bool approve)
    {
        try
        {
            await Api.ResolveAutomoddedMessage(BroadcasterId, held.MessageId, approve);
            held.Resolved = true;
        }
        catch (Exception ex)
        {
            Popup.Add($"The automod resolution failed: {ex.Message}", Severity.Error);
        }
    }

    public void Dispose()
    {
        _eventHandlers.Dispose();
    }
}
